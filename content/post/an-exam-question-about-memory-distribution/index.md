---
title: "一道关于内存分配的期末题"
date: 2023-01-26T15:54:53+08:00
categories:
    - 学习笔记
tags:
    - 笔试题
    - 计算机系统原理
image: images/cover.webp
---
封面图：[https://www.pixiv.net/artworks/95681846](https://www.pixiv.net/artworks/95681846)

曾经我以为没有递归的程序阅读题都是渣渣，直到……
## 题目描述
下面代码进行数组与指针的操作，已知&score[0]的值为 0x00FF2000。
```C
#include <stdio.h>
int main()
{
short int *p1;
long int *p3;
short int score[10] = { 1,2,3,4,5,6,7,8,9 };
p1 = score;
p3 = (long int*)score;
printf("%p, %p\n", p1 + 1, p3 + 1);
printf("%d, %d\n", *p1, *p3);
return 0;
}
```
(1) 请说明数组名score 的含义。

(2) 写出程序执行结果。

非官方答案：
```
(1)指向数组score头元素的指针
(2)
0x00FF2002 0x00FF2004
1 131073
```
注：在64位linux系统上时，第一个printf输出的第二个数应为0x00FF2008
## 题目详解
首先第一小题完全莫名其妙，不讲。

有意思的是第二小题，这个程序有两个`printf`语句，第一个`printf`主要考察指针运算。众所周知，假设指针的类型长度为`n`，那么指针加`k`，指针实际移动`n*k`。在本例中，指针`p1`的类型是`short int *`，`short int`的类型长度是2个字节，此处`p1+1`，实际地址增加2，即`0x00FF2002`。`p3+1`同理。但是这里有个小坑，`long int` 在64位linux系统上是8个字节，在windows上是4个字节。所以答案会有所不同。

第二个printf语句是输出两个指针对应的内容。我们先忽略格式控制符，看后面的两个参数。第一个参数是`*p1`，又因为`p1=score`，`p1`和`score`都是`short int *`类型，所以毫无疑问这里是取`score[0]`，也就是`1`。第二个参数是`*p3`，也有`p3=score`，但是p3是`long int *`，在它执行`*`运算的时候会一次取`long int`长度的内容，也就是取4个字节。然而，一个`short int`类型只占2个字节，所以这里发生了访问溢出。那么这里到底取出来了什么呢？这就需要从内存里分析了。
### 程序内存分配分析
相信大家都很熟悉下面这张图：
![内存分配](images/内存分配.png)
这张图展示了计算机内存分配的顺序。我们知道，对于局部变量，系统在栈区从高地址向低地址分配内存。但是，在数组内部，数组元素从低地址向高地址分配。因此，对于本题而言，程序内存分配就像这样：
| 内存内容   | 内存属主 |
| ---------- | -------- |
| 0x00FF2000 | p1       |
| 0x00FF2000 | p3       |
| 未知       | score[9] |
| 9          | score[8] |
| 8          | score[7] |
| 7          | score[6] |
| 6          | score[5] |
| 5          | score[4] |
| 4          | score[3] |
| 3          | score[2] |
| 2          | score[1] |
| 1          | score[0] |

注：上表并不展示实际占用内存大小，仅展示相对位置关系

除此之外，我们还知道`*`运算符是从低地址向高地址取内容的。由此，我们可以得到各指针的指向及其取`*`之后涉及的内存范围：
| 内存内容 | 内存属主 | 指针              | *                    |
| -------- | -------- | ----------------- | -------------------- |
| ...      | ...      | ...               | ...                  |
| 3        | score[2] | 无                | 无                   |
| 2        | score[1] | 无                | `*p3`                |
| 1        | score[0] | `score`,`p1`,`p3` | `*score`,`*p1`,`*p3` |

由上表可知，`*p3`取的内容是`score[0]`和`score[1]`的拼接。但是，具体如何拼接？我们还需要了解整数是如何以二进制位的方式存储在内存中的。
### 计算机中的整数
一般来说，整数以补码的形式存储在内存中。
> 正数的补码等于其原码，负数的补码等于模减去其绝对值的原码

考虑到short int 占两个字节，也就是16个二进制位，那么可以得到：
```C
(short int)1=0000000000000001
(short int)2=0000000000000010
```
得到了这两个数对应的二进制编码，我们还需要知道它们在内存中的位置。
### 大端机和小端机
和`*`运算符一样，计算机在存储整数时总是从低地址向高地址存储。但是，在存储的时候是最高位在前还是最低位在前呢？由此产生了大端机和小端机两个分支。对于大端机来说，数字的最高位存储在最低的地址，最低位存储在最高的地址。小端机则相反，**将最低位存储在最低的地址，最高位存储在最高的地址**。大多数家用计算机都是小端机。因此，`score[0]`和`score[1]`展开为位在内存中就像这样（从左向右为从低地址向高地址)：
| **1**             | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0        | **1** | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0      |
| ----------------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | -------- | ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ------ |
| score[0] (低地址) | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | score[1] | -     | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | >   | 高地址 |
### 回到`*p3`
因此，`*p3`实际上取的就是像上面这样一串二进制。但是我们阅读数字习惯将高位放在开头，也就是说我们的习惯是大端的，所以我们要将这串二进制倒过来。同时我们不习惯数字开头是0，所以我们去掉前导0，最后结果就像下面这样：
```
10 00000000 00000001(2)=131073(10)
```
除此之外，我们还需要关注格式控制符。幸运的是，这里的格式控制符是`%d`，在Windows平台下刚好能够兼容`*p1`和`*p3`，因此没有什么问题。于是我们能够得出最后的结果：
```
1 131073
```
## 总结
其实这是一道非常简单的关于内存分配的题目，但是背后涉及到的相关知识非常复杂。这里做一个简单的讲解。读者如果有任何想法，欢迎在评论区提出！